// ===== XIAO ESP32C6 RC Joystick Controller =====
// Remote controller for RC_Motors using KY-023 joystick module
// Compatible with ESP-NOW communication protocol
// Author: Generated by Claude Code
// Target: Motor Car receiver (RC_Motors project)

// ===== Library Includes =====
#include <esp_now.h>
#include <WiFi.h>
#include <esp_wifi.h>
#include <Preferences.h>

// ===== Hardware Pin Definitions =====
#define JOYSTICK_VRX_PIN    A0         // Analog pin for X-axis
#define JOYSTICK_VRY_PIN    A1         // Analog pin for Y-axis  
#define JOYSTICK_SW_PIN     D2          // Digital pin for button
#define STATUS_LED_PIN      LED_BUILTIN // Built-in LED

// ===== ESP-NOW Configuration =====
#define ESP_NOW_CHANNEL     1
#define SEND_INTERVAL_MS    50         // 20Hz transmission rate
#define MAX_RETRIES         3

// ===== Joystick Configuration =====
#define JOYSTICK_CENTER_TOLERANCE  50  // Deadband around center
#define JOYSTICK_MIN_THRESHOLD     100 // Minimum meaningful deflection
#define CALIBRATION_HOLD_TIME      3000 // Button hold time for calibration (ms)

// ===== Target Receiver Configuration =====
uint8_t receiverMacAddress[6] = {0xFC, 0xF5, 0xC4, 0x95, 0x97, 0x6C}; // Motor Car

// ===== Data Structures =====
typedef struct rotary_message {
  int encoder1_value;     // Joystick X raw value
  int encoder1_norm;      // Left motor control (-90 to 90)
  int encoder2_value;     // Joystick Y raw value  
  int encoder2_norm;      // Right motor control (-90 to 90)
  bool button_state;      // Joystick button state
  bool button2_state;     // Unused (false)
  uint32_t msg_id;        // Message counter
  uint8_t button_event;   // Button press events
  uint8_t button2_event;  // Unused (0)
} rotary_message;

typedef struct ack_message {
  int rssi;              // Signal strength in dBm
  uint32_t ack_id;       // Confirmation of message ID
} ack_message;

typedef struct joystick_calibration {
  int centerX, centerY;           // Neutral position
  int minX, maxX, minY, maxY;     // Full range values
  bool isCalibrated;              // Calibration status
} joystick_calibration;

// ===== Global Variables =====
rotary_message joystickData;
joystick_calibration calibrationData;
Preferences preferences;

uint32_t messageCounter = 0;
unsigned long lastSendTime = 0;
unsigned long buttonPressStartTime = 0;
bool buttonPressed = false;
bool calibrationMode = false;
int currentJoystickX = 0;
int currentJoystickY = 0;
int lastRSSI = 0;
bool lastSendSuccess = false;

// LED status variables
unsigned long ledLastUpdate = 0;
bool ledState = false;
int ledBlinkInterval = 1000; // Default: solid (slow toggle)

// ===== Function Declarations =====
void initHardware();
void initESPNow();
void loadCalibrationData();
void saveCalibrationData();
void enterCalibrationMode();
void performCalibration();
void readJoystickValues();
void mapJoystickToMotors(int rawX, int rawY, int* leftMotor, int* rightMotor);
void handleCalibrationButton();
void updateStatusLED();
void sendJoystickData();
void printDebugInfo();
void OnDataSent(const uint8_t *mac_addr, esp_now_send_status_t status);
void OnDataRecv(const esp_now_recv_info *recv_info, const uint8_t *incomingData, int len);

// ===== Arduino Setup Function =====
void setup() {
  Serial.begin(115200);
  delay(1000);
  
  Serial.println("=== XIAO ESP32C6 RC Joystick Controller ===");
  Serial.println("Initializing hardware...");
  
  initHardware();
  loadCalibrationData();
  initESPNow();
  
  // Initialize joystick data structure
  memset(&joystickData, 0, sizeof(joystickData));
  joystickData.button2_state = false;
  joystickData.button2_event = 0;
  
  Serial.println("Setup complete - Ready to send joystick commands");
  Serial.print("Target receiver MAC: ");
  for (int i = 0; i < 6; i++) {
    Serial.printf("%02X", receiverMacAddress[i]);
    if (i < 5) Serial.print(":");
  }
  Serial.println();
  
  if (calibrationData.isCalibrated) {
    Serial.println("Joystick calibration loaded from memory");
  } else {
    Serial.println("No calibration found - hold button during startup to calibrate");
  }
}

// ===== Arduino Main Loop =====
void loop() {
  static unsigned long lastDebugTime = 0;
  
  handleCalibrationButton();
  
  if (!calibrationMode) {
    readJoystickValues();
    
    // Send data at specified interval
    if (millis() - lastSendTime >= SEND_INTERVAL_MS) {
      sendJoystickData();
      lastSendTime = millis();
    }
    
    // Debug output every 500ms
    if (millis() - lastDebugTime >= 500) {
      printDebugInfo();
      lastDebugTime = millis();
    }
  }
  
  updateStatusLED();
  delay(10); // Small delay for background tasks
}

// ===== Hardware Initialization =====
void initHardware() {
  // Configure joystick pins
  pinMode(JOYSTICK_SW_PIN, INPUT_PULLUP);
  
  // Configure LED
  pinMode(STATUS_LED_PIN, OUTPUT);
  digitalWrite(STATUS_LED_PIN, LOW);
  
  Serial.println("Hardware initialization complete");
}

// ===== ESP-NOW Initialization =====
void initESPNow() {
  WiFi.mode(WIFI_STA);
  esp_wifi_set_channel(ESP_NOW_CHANNEL, WIFI_SECOND_CHAN_NONE);
  
  if (esp_now_init() != ESP_OK) {
    Serial.println("Error initializing ESP-NOW");
    ledBlinkInterval = 100; // Fast blink for error
    return;
  }
  
  esp_now_register_send_cb(OnDataSent);
  esp_now_register_recv_cb(OnDataRecv);
  
  // Add receiver peer
  esp_now_peer_info_t peerInfo;
  memcpy(peerInfo.peer_addr, receiverMacAddress, 6);
  peerInfo.channel = ESP_NOW_CHANNEL;
  peerInfo.encrypt = false;
  
  if (esp_now_add_peer(&peerInfo) != ESP_OK) {
    Serial.println("Failed to add peer");
    ledBlinkInterval = 100; // Fast blink for error
    return;
  }
  
  Serial.println("ESP-NOW initialized successfully");
  ledBlinkInterval = 1000; // Normal operation
}

// ===== Calibration Data Management =====
void loadCalibrationData() {
  preferences.begin("joystick", true); // Read-only
  
  calibrationData.centerX = preferences.getInt("centerX", 2048);
  calibrationData.centerY = preferences.getInt("centerY", 2048);
  calibrationData.minX = preferences.getInt("minX", 0);
  calibrationData.maxX = preferences.getInt("maxX", 4095);
  calibrationData.minY = preferences.getInt("minY", 0);
  calibrationData.maxY = preferences.getInt("maxY", 4095);
  calibrationData.isCalibrated = preferences.getBool("calibrated", false);
  
  preferences.end();
}

void saveCalibrationData() {
  preferences.begin("joystick", false); // Read-write
  
  preferences.putInt("centerX", calibrationData.centerX);
  preferences.putInt("centerY", calibrationData.centerY);
  preferences.putInt("minX", calibrationData.minX);
  preferences.putInt("maxX", calibrationData.maxX);
  preferences.putInt("minY", calibrationData.minY);
  preferences.putInt("maxY", calibrationData.maxY);
  preferences.putBool("calibrated", true);
  
  preferences.end();
  calibrationData.isCalibrated = true;
}

// ===== Calibration System =====
void enterCalibrationMode() {
  calibrationMode = true;
  ledBlinkInterval = 200; // Fast blink for calibration mode
  
  Serial.println("=== ENTERING CALIBRATION MODE ===");
  Serial.println("Move joystick to all extremes, then center and release button");
  
  // Initialize calibration values
  calibrationData.minX = 4095;
  calibrationData.maxX = 0;
  calibrationData.minY = 4095;
  calibrationData.maxY = 0;
  
  performCalibration();
}

void performCalibration() {
  unsigned long calibrationStartTime = millis();
  bool buttonReleased = false;
  
  while (calibrationMode) {
    int rawX = analogRead(JOYSTICK_VRX_PIN);
    int rawY = analogRead(JOYSTICK_VRY_PIN);
    bool buttonState = !digitalRead(JOYSTICK_SW_PIN);
    
    // Track extremes
    if (rawX < calibrationData.minX) calibrationData.minX = rawX;
    if (rawX > calibrationData.maxX) calibrationData.maxX = rawX;
    if (rawY < calibrationData.minY) calibrationData.minY = rawY;
    if (rawY > calibrationData.maxY) calibrationData.maxY = rawY;
    
    // Check for button release
    if (!buttonState && !buttonReleased) {
      buttonReleased = true;
      Serial.println("Button released - move to center position and press button to finish");
    }
    
    // Check for button press after release (to set center)
    if (buttonState && buttonReleased) {
      calibrationData.centerX = rawX;
      calibrationData.centerY = rawY;
      
      Serial.println("Calibration complete!");
      Serial.printf("Center: X=%d, Y=%d\n", calibrationData.centerX, calibrationData.centerY);
      Serial.printf("Range: X=%d-%d, Y=%d-%d\n", 
                   calibrationData.minX, calibrationData.maxX,
                   calibrationData.minY, calibrationData.maxY);
      
      saveCalibrationData();
      calibrationMode = false;
      ledBlinkInterval = 1000; // Back to normal
      break;
    }
    
    // Timeout after 30 seconds
    if (millis() - calibrationStartTime > 30000) {
      Serial.println("Calibration timeout - using default values");
      calibrationMode = false;
      ledBlinkInterval = 1000;
      break;
    }
    
    updateStatusLED();
    delay(50);
  }
}

// ===== Joystick Reading =====
void readJoystickValues() {
  currentJoystickX = analogRead(JOYSTICK_VRX_PIN);
  currentJoystickY = analogRead(JOYSTICK_VRY_PIN);
  
  // Store raw values
  joystickData.encoder1_value = currentJoystickX;
  joystickData.encoder2_value = currentJoystickY;
  
  // Map to motor controls
  int leftMotor, rightMotor;
  mapJoystickToMotors(currentJoystickX, currentJoystickY, &leftMotor, &rightMotor);
  
  joystickData.encoder1_norm = leftMotor;   // Left motor
  joystickData.encoder2_norm = rightMotor;  // Right motor
  
  // Button state
  joystickData.button_state = !digitalRead(JOYSTICK_SW_PIN);
}

// ===== Joystick to Motor Mapping =====
void mapJoystickToMotors(int rawX, int rawY, int* leftMotor, int* rightMotor) {
  if (!calibrationData.isCalibrated) {
    *leftMotor = 0;
    *rightMotor = 0;
    return;
  }
  
  // Normalize X and Y to -90 to +90 range
  int normalizedX = map(rawX, calibrationData.minX, calibrationData.maxX, -90, 90);
  int normalizedY = map(rawY, calibrationData.minY, calibrationData.maxY, -90, 90);
  
  // Apply center deadband
  if (abs(normalizedX) < JOYSTICK_MIN_THRESHOLD * 90 / 2048) normalizedX = 0;
  if (abs(normalizedY) < JOYSTICK_MIN_THRESHOLD * 90 / 2048) normalizedY = 0;
  
  // Constrain to valid range
  normalizedX = constrain(normalizedX, -90, 90);
  normalizedY = constrain(normalizedY, -90, 90);
  
  // Tank drive mixing:
  // Y-axis controls forward/backward (throttle)
  // X-axis controls left/right steering (differential)
  
  int throttle = normalizedY;  // Forward/backward (inverted for head/tail swap)
  int steering = normalizedX / 2;  // Left/right at half speed
  
  // Invert steering when going backward for intuitive control
  if (throttle < 0) {
    steering = -steering;
  }
  
  // Calculate individual motor speeds
  *leftMotor = throttle - steering;   // Left motor
  *rightMotor = throttle + steering;  // Right motor
  
  // Constrain final values
  *leftMotor = constrain(*leftMotor, -90, 90);
  *rightMotor = constrain(*rightMotor, -90, 90);
}

// ===== Button Handling =====
void handleCalibrationButton() {
  bool currentButtonState = !digitalRead(JOYSTICK_SW_PIN);
  
  if (currentButtonState && !buttonPressed) {
    // Button press detected
    buttonPressed = true;
    buttonPressStartTime = millis();
    joystickData.button_event = 1; // Single click event
  } else if (!currentButtonState && buttonPressed) {
    // Button released
    unsigned long pressDuration = millis() - buttonPressStartTime;
    
    if (pressDuration >= CALIBRATION_HOLD_TIME) {
      // Long press - enter calibration
      enterCalibrationMode();
    }
    
    buttonPressed = false;
    joystickData.button_event = 0; // Clear event
  }
}

// ===== LED Status Management =====
void updateStatusLED() {
  if (millis() - ledLastUpdate >= ledBlinkInterval) {
    ledState = !ledState;
    digitalWrite(STATUS_LED_PIN, ledState);
    ledLastUpdate = millis();
  }
}

// ===== Data Transmission =====
void sendJoystickData() {
  joystickData.msg_id = ++messageCounter;
  
  esp_err_t result = esp_now_send(receiverMacAddress, (uint8_t*)&joystickData, sizeof(joystickData));
  lastSendSuccess = (result == ESP_OK);
  
  if (!lastSendSuccess) {
    ledBlinkInterval = 300; // Medium blink for send errors
  } else if (ledBlinkInterval == 300) {
    ledBlinkInterval = 1000; // Back to normal if recovering from error
  }
}

// ===== Communication Callbacks =====
void OnDataSent(const uint8_t *mac_addr, esp_now_send_status_t status) {
  lastSendSuccess = (status == ESP_NOW_SEND_SUCCESS);
}

void OnDataRecv(const esp_now_recv_info *recv_info, const uint8_t *incomingData, int len) {
  if (len == sizeof(ack_message)) {
    ack_message ackMsg;
    memcpy(&ackMsg, incomingData, sizeof(ackMsg));
    lastRSSI = ackMsg.rssi;
  }
}

// ===== Debug Output =====
void printDebugInfo() {
  if (!calibrationMode) {
    Serial.printf("Joy X:%4d Y:%4d | Motors L:%3d R:%3d | Btn:%d | RSSI:%d | Msg:%lu\n",
                  currentJoystickX, currentJoystickY,
                  joystickData.encoder1_norm, joystickData.encoder2_norm,
                  joystickData.button_state, lastRSSI, messageCounter);
  }
}